import random
import time

from Algorithm import Algorithm
from Graph import Graph
from Random_path import RandomAlgorithm
from random import choices
import numpy as np

# DISTANCE_COEF = 2
# PHEROMONES_COEF = 3
# PHEROMONES_EVAP = 0.2


DISTANCE_COEF = 0.5
PHEROMONES_COEF = 1.8
PHEROMONES_EVAP = 0.6392857142857143
PHEROMONES_ENCH = 1


class AntAlgorithm(Algorithm):
    def create_pher_dist_matrix(self):
        self.matrix = []
        for i in range(self.graph.get_n_points()):
            self.matrix.append([])
            for j in range(self.graph.get_n_points()):
                if i == j:
                    self.matrix[-1].append(None)
                else:
                    self.matrix[-1].append([self.graph.calculate_distance(i, j), 1])
        # print(*self.matrix, sep="\n")

    def solve(self, start=0, ants=10, iter=200):
        min_path, min_dist, _ = RandomAlgorithm(self.graph).solve(start)
        self.create_pher_dist_matrix()
        start_time = time.time()
        for i in range(iter):
            ant_paths = []
            for a in range(ants):
                path = [start]
                dist = 0
                pos_points = self.graph.get_points().copy()
                del pos_points[start]
                for _ in range(self.graph.get_n_points() - 1):
                    weights = dict()
                    for p in pos_points.keys():
                        attr = self.matrix[path[-1]][p][0] ** DISTANCE_COEF + self.matrix[path[-1]][p][1] ** PHEROMONES_COEF
                        weights[p] = attr
                    s_attr = sum(weights.values())
                    # for w in weights.keys():
                    #     weights[w] /= s_attr
                    # try:
                    s = 0
                    r = random.uniform(0, s_attr)
                    for k in dict(sorted(weights.items(), key=lambda item: item[1])).keys():
                        s += weights[k]
                        if s > r:
                            sel_point = k
                            break

                    # sel_point = choices(pos_points, weights, k=1)[0]
                    # except BaseException as e:
                    #     print(path)
                    #     print(pos_points)
                    #     print(weights)
                    #     print(weights.keys())
                    #     print(weights.values())
                    #     exit()
                    # for p in pos_points.keys():
                    #     if pos_points[p] == sel_point:
                    #         sel_point = p
                    #         break
                    # else:
                    #     print(sel_point)
                    #     print(pos_points)
                    dist += self.matrix[path[-1]][sel_point][0]
                    path.append(sel_point)
                    del pos_points[sel_point]
                path.append(start)
                dist += self.matrix[path[-2]][path[-1]][0]
                ant_paths.append((path, dist))
                if dist < min_dist:
                    min_path, min_dist = path, dist

            for j in range(len(self.matrix)):
                for k in range(len(self.matrix[j])):
                    if k != j:
                        self.matrix[j][k][1] *= (1 - PHEROMONES_EVAP)
            for ap in ant_paths:
                pheromones = PHEROMONES_ENCH / ap[1]
                for j in range(len(ap[0]) - 1):
                    self.matrix[ap[0][j]][ap[0][j + 1]][1] += pheromones
            # if i % 10 == 9:
            #     print(f"{i + 1} Итерация пройдена")
        # print(*self.matrix, sep="\n")
        end_time = time.time()
        total_time = end_time - start_time
        return min_path, min_dist, total_time


if __name__ == "__main__":
    # points = [(10, 10, 10), (9, 1, 10), (3, 5, 10), (5, 5, 10), (9, 9, 2), (1, 1, 5), (5, 9, 6), (8, 15, 8), (9, 5, 2)]
    points = [(91.7311459346491, 15.342820268851298, 77.53479746150663), (62.595798272237445, 94.58617578743547, 99.76370379060849), (74.32021743917898, 56.6362601791274, 29.58346499534801), (36.12229467034849, 47.75829366597794, 84.95218127238945), (0.9613939628796975, 40.81584061580516, 77.34242626106106), (87.16464560697416, 12.903054589685581, 13.084325187436862), (70.18511661550662, 71.42918835363741, 57.97018380425412), (16.159047192582587, 93.80791835406649, 51.77476525745684), (75.68100170077795, 83.46932150606358, 35.24274070868005), (76.49678612764977, 79.33331499612642, 85.75161288966933), (9.128753146533208, 86.22003390470118, 28.039898275495723), (45.86776165196835, 32.588278037569864, 50.02916622882233), (12.58025051971785, 25.61088225221776, 0.9660423520892469), (80.37192050955042, 90.20015699100932, 6.168015966092987), (55.65352854222125, 61.072486581627636, 95.20969582429714), (67.2337845583764, 4.82705217854511, 13.367546244563389), (24.26393457790823, 35.93678283168128, 50.99531022401784), (52.013751258468425, 36.61358585648403, 40.51360995569455), (81.72858167732934, 73.98030635033679, 84.35847992012513), (9.373415583680867, 92.35302614484439, 42.951974600052786), (65.73355891122839, 19.09766766823121, 3.6378746628049075), (84.18672557499427, 41.17215198314664, 7.864123283782032), (45.922489302436546, 88.70769938729741, 19.137911376170603), (18.246282347494436, 10.10243270408795, 22.34060404278113), (63.52286031137283, 4.842791078971153, 69.72630454510089), (21.353827980658522, 10.979107156744494, 98.42176479763371), (42.064685225405675, 26.059234649235552, 60.392123963783526), (12.624596891592788, 14.371580899234893, 81.15915767830056), (26.684769194697864, 16.51702279504391, 46.2655877031674), (32.83621222526592, 3.759246766932034, 77.82822806911935), (19.58741806516725, 58.398418907367486, 83.30120538805402), (35.5590273452646, 11.305304047980492, 2.9175746004953207), (52.94645066291373, 89.02542101901997, 90.70155263130502), (31.820067796642004, 60.196244125375344, 64.71304819339824), (72.99489843193115, 44.34248331032842, 7.45812465825254), (6.358766342434096, 63.83955241344738, 7.8963548650051285), (2.056932280996193, 28.43510634094779, 34.84738850974377), (98.26392818443607, 29.35541575144799, 46.59418235980066), (53.40201691411819, 36.33661538807981, 29.135273868591284), (33.50986881993408, 53.04054129071377, 54.30528385740385), (9.96477401653334, 29.256770850166625, 20.876531458924962), (83.34886780793163, 30.105812959314616, 71.06605926064599), (98.88608728909477, 73.16913694337688, 49.79807914224976), (87.89200760228317, 73.62082341406177, 1.4393478344569166), (23.3083609558999, 97.04783605583948, 60.314720194402426), (18.16948409500496, 91.42043119883677, 37.48795578996602), (91.36171496447287, 25.498050296647, 36.19746021573466), (2.793964593699494, 54.303805956236374, 69.19203821504212), (27.458550236345737, 16.70103035870546, 96.24534909179019), (45.22411357243612, 5.9191234849254375, 89.53341625046613)]
    graph = Graph(*points)
    algorithm = AntAlgorithm(graph)
    start = 1  # 9, 1
    path, dist, tot_time = algorithm.solve(start)
    print(" -> ".join([str(i) for i in path]))
    print(dist)
    print(tot_time)
    graph.visualize_path_plotly(path)
    # #1 -> 5 -> 3 -> 2 -> 4 -> 8 -> 6 -> 0 -> 7
    # #43.00899537064003

    # points = [[(16, 2), (44, 11), (43, 25), (35, 22), (14, 21), (49, 13), (8, 19), (43, 30)],
    #           [(43, 63), (91, 11), (85, 87), (102, 82), (97, 3), (17, 83), (105, 55), (78, 36), (55, 110), (52, 36),
    #            (74, 117)],
    #           [(173, 483), (2, 63), (395, 149), (148, 208), (168, 213), (179, 108), (12, 436), (491, 350), (332, 242),
    #            (329, 77), (160, 336)],
    #           [(92, 313), (447, 94), (410, 409), (419, 12), (231, 418), (20, 198), (439, 393), (50, 290), (454, 301),
    #            (67, 333), (166, 423), (492, 385)],
    #           [(474, 16), (125, 185), (147, 104), (208, 407), (587, 112), (207, 365), (585, 385), (219, 226), (130, 364),
    #            (535, 128), (222, 248)], [(388, 704), (652, 254), (60, 447), (525, 460), (616, 469), (187, 762)],
    #           [(96, 478), (203, 396), (299, 208), (314, 418), (95, 250), (76, 150), (141, 13), (357, 324), (311, 340),
    #            (275, 148), (25, 129), (499, 462), (123, 404), (385, 135)],
    #           [(866, 689), (253, 759), (753, 330), (652, 623), (564, 134), (775, 846), (46, 30), (585, 892), (54, 405),
    #            (705, 149), (605, 862), (586, 307)],
    #           [(318, 533), (555, 484), (514, 657), (433, 245), (280, 643), (651, 145), (120, 256), (417, 302), (713, 628)],
    #           [(5375, 9525), (8185, 9104), (6297, 8263), (4784, 1158), (1595, 7732), (6567, 1326), (9932, 459), (401, 5714),
    #            (1959, 4038), (5202, 4721), (3320, 204), (4380, 5887), (9121, 8389), (9792, 5669)],
    #           [(97132, 58762), (10327, 55605), (81846, 63793), (15918, 80285), (5799, 51326), (17271, 78701), (6439, 79407),
    #            (17364, 18446), (14472, 473)],
    #           [(21607, 4018), (4282, 44098), (43993, 2959), (21009, 1075), (1251, 23229), (2365, 8349), (15543, 5115),
    #            (46985, 27441), (36373, 7250), (28810, 8124), (3786, 45491), (20123, 19978), (42637, 20224), (5951, 25896),
    #            (13310, 38973)],
    #           [(27, 393), (268, 393), (224, 439), (652, 486), (618, 491), (242, 926), (145, 603), (451, 339), (837, 488),
    #            (187, 505), (616, 242), (729, 889), (863, 994), (558, 928)]]
    #
    # min_consts = (100000000000,)

    # for DISTANCE_COEF in np.linspace(0.5, 3, 26):
    #     for PHEROMONES_COEF in np.linspace(0.5, 3, 26):
    #         for PHEROMONES_EVAP in np.linspace(0.05, 0.8, 15):
    #             s = 0
    #             for p in points:
    #                 algo = AntAlgorithm(Graph(*p))
    #                 s += algo.solve(1)[1]
    #             for p in points:
    #                 algo = AntAlgorithm(Graph(*p))
    #                 s += algo.solve(1)[1]
    #             for p in points:
    #                 algo = AntAlgorithm(Graph(*p))
    #                 s += algo.solve(1)[1]
    #             if s < min_consts[0]:
    #                 min_consts = (s, DISTANCE_COEF, PHEROMONES_COEF, PHEROMONES_EVAP)
    #                 print(f"PATH:{s} DISTANCE_COEF:{DISTANCE_COEF} PHEROMONES_COEF:{PHEROMONES_COEF} PHEROMONES_EVAP:{PHEROMONES_EVAP}")
    #     print(DISTANCE_COEF)
